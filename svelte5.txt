
What are runes?
rune /roÕûon/ noun

A letter or mark used as a mystical or magic symbol.

Runes are symbols that you use in .svelte and .svelte.js / .svelte.ts files to control the Svelte compiler. If you think of Svelte as a language, runes are part of the syntax ‚Äî they are keywords.

Runes have a $ prefix and look like functions:


let message = $state('hello');
They differ from normal JavaScript functions in important ways, however:

You don‚Äôt need to import them ‚Äî they are part of the language
They‚Äôre not values ‚Äî you can‚Äôt assign them to a variable or pass them as arguments to a function
Just like JavaScript keywords, they are only valid in certain positions (the compiler will help you if you put them in the wrong place)
Runes didn‚Äôt exist prior to Svelte 5.



The $state rune allows you to create reactive state, which means that your UI reacts when it changes.


<script>
	let count = $state(0);
</script>

<button onclick={() => count++}>
	clicks: {count}
</button>
Unlike other frameworks you may have encountered, there is no API for interacting with state ‚Äî count is just a number, rather than an object or a function, and you can update it like you would update any other variable.

Deep state
If $state is used with an array or a simple object, the result is a deeply reactive state proxy. Proxies allow Svelte to run code when you read or write properties, including via methods like array.push(...), triggering granular updates.

Classes like Set and Map will not be proxied, but Svelte provides reactive implementations for various built-ins like these that can be imported from svelte/reactivity.

State is proxified recursively until Svelte finds something other than an array or simple object. In a case like this...


let todos = $state([
	{
		done: false,
		text: 'add more todos'
	}
]);
...modifying an individual todo‚Äôs property will trigger updates to anything in your UI that depends on that specific property:


todos[0].done = !todos[0].done;
If you push a new object to the array, it will also be proxified:


todos.push({
	done: false,
	text: 'eat lunch'
});
When you update properties of proxies, the original object is not mutated.

Classes
You can also use $state in class fields (whether public or private):


class Todo {
	done = $state(false);
	text = $state();

	constructor(text) {
		this.text = text;
	}

	reset() {
		this.text = '';
		this.done = false;
	}
}
The compiler transforms done and text into get / set methods on the class prototype referencing private fields.

$state.raw
In cases where you don‚Äôt want objects and arrays to be deeply reactive you can use $state.raw.

State declared with $state.raw cannot be mutated; it can only be reassigned. In other words, rather than assigning to a property of an object, or using an array method like push, replace the object or array altogether if you‚Äôd like to update it:


let person = $state.raw({
	name: 'Heraclitus',
	age: 49
});

// this will have no effect
person.age += 1;

// this will work, because we're creating a new person
person = {
	name: 'Heraclitus',
	age: 50
};
This can improve performance with large arrays and objects that you weren‚Äôt planning to mutate anyway, since it avoids the cost of making them reactive. Note that raw state can contain reactive state (for example, a raw array of reactive objects).

$state.snapshot
To take a static snapshot of a deeply reactive $state proxy, use $state.snapshot:


<script>
	let counter = $state({ count: 0 });

	function onclick() {
		// Will log `{ count: ... }` rather than `Proxy { ... }`
		console.log($state.snapshot(counter));
	}
</script>
This is handy when you want to pass some state to an external library or API that doesn‚Äôt expect a proxy, such as structuredClone.


$derived
On this page
$derived
$derived.by
Derived state is declared with the $derived rune:


<script>
	let count = $state(0);
	let doubled = $derived(count * 2);
</script>

<button onclick={() => count++}>
	{doubled}
</button>

<p>{count} doubled is {doubled}</p>
The expression inside $derived(...) should be free of side-effects. Svelte will disallow state changes (e.g. count++) inside derived expressions.

As with $state, you can mark class fields as $derived.

$derived.by
Sometimes you need to create complex derivations that don‚Äôt fit inside a short expression. In these cases, you can use $derived.by which accepts a function as its argument.


<script>
	let numbers = $state([1, 2, 3]);
	let total = $derived.by(() => {
		let total = 0;
		for (const n of numbers) {
			total += n;
		}
		return total;
	});
</script>

<button onclick={() => numbers.push(numbers.length + 1)}>
	{numbers.join(' + ')} = {total}
</button>
In essence, $derived(expression) is equivalent to $derived.by(() => expression).


$effect
On this page
$effect
$effect.pre
$effect.tracking
$effect.root
When not to use effects
Effects are what make your application do things. When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed, and re-runs the function when that state later changes.

Most of the effects in a Svelte app are created by Svelte itself ‚Äî they‚Äôre the bits that update the text in <h1>hello {name}!</h1> when name changes, for example.

But you can also create your own effects with the $effect rune, which is useful when you need to synchronize an external system (whether that‚Äôs a library, or a <canvas> element, or something across a network) with state inside your Svelte app.

Avoid overusing effects! When you do too much work in them, code often becomes difficult to understand and maintain. See when not to use effects to learn about alternative approaches.

Your effects run after the component has been mounted to the DOM, and in a microtask after state changes (demo):


<script>
	let size = $state(50);
	let color = $state('#ff3e00');

	let canvas;

	$effect(() => {
		const context = canvas.getContext('2d');
		context.clearRect(0, 0, canvas.width, canvas.height);

		// this will re-run whenever `color` or `size` change
		context.fillStyle = color;
		context.fillRect(0, 0, size, size);
	});
</script>

<canvas bind:this={canvas} width="100" height="100" />
Re-runs are batched (i.e. changing color and size in the same moment won‚Äôt cause two separate runs), and happen after any DOM updates have been applied.

You can place $effect anywhere, not just at the top level of a component, as long as it is called during component initialization (or while a parent effect is active). It is then tied to the lifecycle of the component (or parent effect) and will therefore destroy itself when the component unmounts (or the parent effect is destroyed).

You can return a function from $effect, which will run immediately before the effect re-runs, and before it is destroyed (demo).


<script>
	let count = $state(0);
	let milliseconds = $state(1000);

	$effect(() => {
		// This will be recreated whenever `milliseconds` changes
		const interval = setInterval(() => {
			count += 1;
		}, milliseconds);

		return () => {
			// if a callback is provided, it will run
			// a) immediately before the effect re-runs
			// b) when the component is destroyed
			clearInterval(interval);
		};
	});
</script>

<h1>{count}</h1>

<button onclick={() => (milliseconds *= 2)}>slower</button>
<button onclick={() => (milliseconds /= 2)}>faster</button>
Understanding dependencies
$effect automatically picks up any reactive values ($state, $derived, $props) that are synchronously read inside its function body and registers them as dependencies. When those dependencies change, the $effect schedules a rerun.

Values that are read asynchronously ‚Äî after an await or inside a setTimeout, for example ‚Äî will not be tracked. Here, the canvas will be repainted when color changes, but not when size changes (demo):


$effect(() => {
	const context = canvas.getContext('2d');
	context.clearRect(0, 0, canvas.width, canvas.height);

	// this will re-run whenever `color` changes...
	context.fillStyle = color;

	setTimeout(() => {
		// ...but not when `size` changes
		context.fillRect(0, 0, size, size);
	}, 0);
});
An effect only reruns when the object it reads changes, not when a property inside it changes. (If you want to observe changes inside an object at dev time, you can use $inspect.)


<script>
	let state = $state({ value: 0 });
	let derived = $derived({ value: state.value * 2 });

	// this will run once, because `state` is never reassigned (only mutated)
	$effect(() => {
		state;
	});

	// this will run whenever `state.value` changes...
	$effect(() => {
		state.value;
	});

	// ...and so will this, because `derived` is a new object each time
	$effect(() => {
		derived;
	});
</script>

<button onclick={() => (state.value += 1)}>
	{state.value}
</button>

<p>{state.value} doubled is {derived.value}</p>
An effect only depends on the values that it read the last time it ran. If a is true, changes to b will not cause this effect to rerun:


$effect(() => {
	console.log('running');

	if (a || b) {
		console.log('inside if block');
	}
});
$effect.pre
In rare cases, you may need to run code before the DOM updates. For this we can use the $effect.pre rune:


<script>
	import { tick } from 'svelte';

	let div = $state();
	let messages = $state([]);

	// ...

	$effect.pre(() => {
		if (!div) return; // not yet mounted

		// reference `messages` array length so that this code re-runs whenever it changes
		messages.length;

		// autoscroll when new messages are added
		if (div.offsetHeight + div.scrollTop > div.scrollHeight - 20) {
			tick().then(() => {
				div.scrollTo(0, div.scrollHeight);
			});
		}
	});
</script>

<div bind:this={div}>
	{#each messages as message}
		<p>{message}</p>
	{/each}
</div>
Apart from the timing, $effect.pre works exactly like $effect.

$effect.tracking
The $effect.tracking rune is an advanced feature that tells you whether or not the code is running inside a tracking context, such as an effect or inside your template (demo):


<script>
	console.log('in component setup:', $effect.tracking()); // false

	$effect(() => {
		console.log('in effect:', $effect.tracking()); // true
	});
</script>

<p>in template: {$effect.tracking()}</p> <!-- true -->
This allows you to (for example) add things like subscriptions without causing memory leaks, by putting them in child effects. Here‚Äôs a readable function that listens to changes from a callback function as long as it‚Äôs inside a tracking context:


import { tick } from 'svelte';

export default function readable<T>(
	initial_value: T,
	start: (callback: (update: (v: T) => T) => T) => () => void
) {
	let value = $state(initial_value);

	let subscribers = 0;
	let stop: null | (() => void) = null;

	return {
		get value() {
			// If in a tracking context ...
			if ($effect.tracking()) {
				$effect(() => {
					// ...and there's no subscribers yet...
					if (subscribers === 0) {
						// ...invoke the function and listen to changes to update state
						stop = start((fn) => (value = fn(value)));
					}

					subscribers++;

					// The return callback is called once a listener unlistens
					return () => {
						tick().then(() => {
							subscribers--;
							// If it was the last subscriber...
							if (subscribers === 0) {
								// ...stop listening to changes
								stop?.();
								stop = null;
							}
						});
					};
				});
			}

			return value;
		}
	};
}
$effect.root
The $effect.root rune is an advanced feature that creates a non-tracked scope that doesn‚Äôt auto-cleanup. This is useful for nested effects that you want to manually control. This rune also allows for creation of effects outside of the component initialisation phase.


<script>
	let count = $state(0);

	const cleanup = $effect.root(() => {
		$effect(() => {
			console.log(count);
		});

		return () => {
			console.log('effect root cleanup');
		};
	});
</script>
When not to use effects
In general, $effect is best considered something of an escape hatch ‚Äî useful for things like analytics and direct DOM manipulation ‚Äî rather than a tool you should use frequently. In particular, avoid using it to synchronise state. Instead of this...


<script>
	let count = $state(0);
	let doubled = $state();

	// don't do this!
	$effect(() => {
		doubled = count * 2;
	});
</script>
...do this:


<script>
	let count = $state(0);
	let doubled = $derived(count * 2);
</script>
For things that are more complicated than a simple expression like count * 2, you can also use $derived.by.

You might be tempted to do something convoluted with effects to link one value to another. The following example shows two inputs for ‚Äúmoney spent‚Äù and ‚Äúmoney left‚Äù that are connected to each other. If you update one, the other should update accordingly. Don‚Äôt use effects for this (demo):


<script>
	let total = 100;
	let spent = $state(0);
	let left = $state(total);

	$effect(() => {
		left = total - spent;
	});

	$effect(() => {
		spent = total - left;
	});
</script>

<label>
	<input type="range" bind:value={spent} max={total} />
	{spent}/{total} spent
</label>

<label>
	<input type="range" bind:value={left} max={total} />
	{left}/{total} left
</label>
Instead, use callbacks where possible (demo):


<script>
	let total = 100;
	let spent = $state(0);
	let left = $state(total);

	function updateSpent(e) {
		spent = +e.target.value;
		left = total - spent;
	}

	function updateLeft(e) {
		left = +e.target.value;
		spent = total - left;
	}
</script>

<label>
	<input type="range" value={spent} oninput={updateSpent} max={total} />
	{spent}/{total} spent
</label>

<label>
	<input type="range" value={left} oninput={updateLeft} max={total} />
	{left}/{total} left
</label>
If you need to use bindings, for whatever reason (for example when you want some kind of ‚Äúwritable $derived‚Äú), consider using getters and setters to synchronise state (demo):


<script>
	let total = 100;
	let spent = $state(0);

	let left = {
		get value() {
			return total - spent;
		},
		set value(v) {
			spent = total - v;
		}
	};
</script>

<label>
	<input type="range" bind:value={spent} max={total} />
	{spent}/{total} spent
</label>

<label>
	<input type="range" bind:value={left.value} max={total} />
	{left.value}/{total} left
</label>
If you absolutely have to update $state within an effect and run into an infinite loop because you read and write to the same $state, use untrack.


SvelteRunes
$props
On this page
$props
Fallback values
Renaming props
Rest props
Updating props
Type safety
The inputs to a component are referred to as props, which is short for properties. You pass props to components just like you pass attributes to elements:

App

<script>
	import MyComponent from './MyComponent.svelte';
</script>

<MyComponent adjective="cool" />
On the other side, inside MyComponent.svelte, we can receive props with the $props rune...

MyComponent

<script>
	let props = $props();
</script>

<p>this component is {props.adjective}</p>
...though more commonly, you‚Äôll destructure your props:

MyComponent

<script>
	let { adjective } = $props();
</script>

<p>this component is {adjective}</p>
Fallback values
Destructuring allows us to declare fallback values, which are used if the parent component does not set a given prop:

MyComponent

let { adjective = 'happy' } = $props();
Fallback values are not turned into reactive state proxies.

Renaming props
We can also use the destructuring assignment to rename props, which is necessary if they‚Äôre invalid identifiers, or a JavaScript keyword like super:


let { super: trouper = 'lights are gonna find me' } = $props();
Rest props
Finally, we can use a rest property to get, well, the rest of the props:


let { a, b, c, ...others } = $props();
Updating props
References to a prop inside a component update when the prop itself updates ‚Äî when count changes in App.svelte, it will also change inside Child.svelte. But the child component is able to temporarily override the prop value, which can be useful for unsaved ephemeral state (demo):

App

<script>
	import Child from './Child.svelte';

	let count = $state(0);
</script>

<button onclick={() => (count += 1)}>
	clicks (parent): {count}
</button>

<Child {count} />
Child

<script>
	let { count } = $props();
</script>

<button onclick={() => (count += 1)}>
	clicks (child): {count}
</button>
Type safety
You can add type safety to your components by annotating your props, as you would with any other variable declaration. In TypeScript that might look like this...


<script lang="ts">
	let { adjective }: { adjective: string } = $props();
</script>
...while in JSDoc you can do this:


<script>
	/** @type {{ adjective: string }} */
	let { adjective } = $props();
</script>
You can, of course, separate the type declaration from the annotation:


<script lang="ts">
	interface Props {
		adjective: string;
	}

	let { adjective }: Props = $props();
</script>
Adding types is recommended, as it ensures that people using your component can easily discover which props they should provide.


SvelteIntroduction
.svelte.js and .svelte.ts files
On this page
.svelte.js and .svelte.ts files
Besides .svelte files, Svelte also operates on .svelte.js and .svelte.ts files.

These behave like any other .js or .ts module, except that you can use runes. This is useful for creating reusable reactive logic, or sharing reactive state across your app.

This is a concept that didn‚Äôt exist prior to Svelte 5


Skip to main content
Introduction
Runes
Template syntax
Styling
Special elements
Runtime
Misc
Reference
Legacy APIs
SvelteMisc
Svelte 5 migration guide
On this page
Svelte 5 migration guide
Reactivity syntax changes
Event changes
Snippets instead of slots
Migration script
Components are no longer classes
Whitespace handling changed
Modern browser required
Changes to compiler options
The children prop is reserved
Dot notation indicates a component
Breaking changes in runes mode
Other breaking changes
Version 5 comes with an overhauled syntax and reactivity system. While it may look different at first, you‚Äôll soon notice many similarities. This guide goes over the changes in detail and shows you how to upgrade. Along with it, we also provide information on why we did these changes.

You don‚Äôt have to migrate to the new syntax right away - Svelte 5 still supports the old Svelte 4 syntax, and you can mix and match components using the new syntax with components using the old and vice versa. We expect many people to be able to upgrade with only a few lines of code changed initially. There‚Äôs also a migration script that helps you with many of these steps automatically.

Reactivity syntax changes
At the heart of Svelte 5 is the new runes API. Runes are basically compiler instructions that inform Svelte about reactivity. Syntactically, runes are functions starting with a dollar-sign.

let -> $state
In Svelte 4, a let declaration at the top level of a component was implicitly reactive. In Svelte 5, things are more explicit: a variable is reactive when created using the $state rune. Let‚Äôs migrate the counter to runes mode by wrapping the counter in $state:


<script>
	let count = $state(0);
</script>
Nothing else changes. count is still the number itself, and you read and write directly to it, without a wrapper like .value or getCount().

$: -> $derived/$effect
In Svelte 4, a $: statement at the top level of a component could be used to declare a derivation, i.e. state that is entirely defined through a computation of other state. In Svelte 5, this is achieved using the $derived rune:


<script>
	let count = $state(0);
	$: const double = $derived(count * 2);
</script>
As with $state, nothing else changes. double is still the number itself, and you read it directly, without a wrapper like .value or getCount().

A $: statement could also be used to create side effects. In Svelte 5, this is achieved using the $effect rune:


<script>
	let count = $state(0);
	$:$effect(() => {
		if (count > 5) {
			alert('Count is too high!');
		}
	});
</script>
export let -> $props
In Svelte 4, properties of a component were declared using export let. Each property was one declaration. In Svelte 5, all properties are declared through the $props rune, through destructuring:


<script>
	export let optional = 'unset';
	export let required;
	let { optional = 'unset', required } = $props();
</script>
There are multiple cases where declaring properties becomes less straightforward than having a few export let declarations:

you want to rename the property, for example because the name is a reserved identifier (e.g. class)
you don‚Äôt know which other properties to expect in advance
you want to forward every property to another component
All these cases need special syntax in Svelte 4:

renaming: export { klass as class}
other properties: $$restProps
all properties $$props
In Svelte 5, the $props rune makes this straightforward without any additional Svelte-specific syntax:

renaming: use property renaming let { class: klass } = $props();
other properties: use spreading let { foo, bar, ...rest } = $props();
all properties: don‚Äôt destructure let props = $props();

<script>
	let klass = '';
	export { klass as class};
	let { class: klass, ...rest } = $props();
</script>
<button {class} {...$$restPropsrest}>click me</button>
Event changes
Event handlers have been given a facelift in Svelte 5. Whereas in Svelte 4 we use the on: directive to attach an event listener to an element, in Svelte 5 they are properties like any other (in other words - remove the colon):


<script>
	let count = $state(0);
</script>

<button on:click={() => count++}>
	clicks: {count}
</button>
Since they‚Äôre just properties, you can use the normal shorthand syntax...


<script>
	let count = $state(0);

	function onclick() {
		count++;
	}
</script>

<button {onclick}>
	clicks: {count}
</button>
...though when using a named event handler function it‚Äôs usually better to use a more descriptive name.

Component events
In Svelte 4, components could emit events by creating a dispatcher with createEventDispatcher.

This function is deprecated in Svelte 5. Instead, components should accept callback props - which means you then pass functions as properties to these components:

App

<script>
	import Pump from './Pump.svelte';

	let size = $state(15);
	let burst = $state(false);

	function reset() {
		size = 15;
		burst = false;
	}
</script>

<Pump
	on:inflate={(power) => {
		size += power.details;
		if (size > 75) burst = true;
	}}
	on:deflate={(power) => {
		if (size > 0) size -= power.details;
	}}
/>

{#if burst}
	<button onclick={reset}>new balloon</button>
	<span class="boom">üí•</span>
{:else}
	<span class="balloon" style="scale: {0.01 * size}">
		üéà
	</span>
{/if}
Pump

<script>
	import { createEventDispatcher } from 'svelte';
	const dispatch = createEventDispatcher();
	
	let { inflate, deflate } = $props();
	let power = $state(5);
</script>

<button onclick={() => dispatch('inflate', power)inflate(power)}>
	inflate
</button>
<button onclick={() => dispatch('deflate', power)deflate(power)}>
	deflate
</button>
<button onclick={() => power--}>-</button>
Pump power: {power}
<button onclick={() => power++}>+</button>
Bubbling events
Instead of doing <button on:click> to ‚Äòforward‚Äô the event from the element to the component, the component should accept an onclick callback prop:


<script>
	let { onclick } = $props();
</script>

<button on:click {onclick}>
	click me
</button>
Note that this also means you can ‚Äòspread‚Äô event handlers onto the element along with other props instead of tediously forwarding each event separately:


<script>
	let props = $props();
</script>

<button {...$$props} on:click on:keydown on:all_the_other_stuff {...props}>
	click me
</button>
Event modifiers
In Svelte 4, you can add event modifiers to handlers:


<button on:click|once|preventDefault={handler}>...</button>
Modifiers are specific to on: and as such do not work with modern event handlers. Adding things like event.preventDefault() inside the handler itself is preferable, since all the logic lives in one place rather than being split between handler and modifiers.

Since event handlers are just functions, you can create your own wrappers as necessary:


<script>
	function once(fn) {
		return function (event) {
			if (fn) fn.call(this, event);
			fn = null;
		};
	}

	function preventDefault(fn) {
		return function (event) {
			event.preventDefault();
			fn.call(this, event);
		};
	}
</script>

<button onclick={once(preventDefault(handler))}>...</button>
There are three modifiers ‚Äî capture, passive and nonpassive ‚Äî that can‚Äôt be expressed as wrapper functions, since they need to be applied when the event handler is bound rather than when it runs.

For capture, we add the modifier to the event name:


<button onclickcapture={...}>...</button>
Changing the passive option of an event handler, meanwhile, is not something to be done lightly. If you have a use case for it ‚Äî and you probably don‚Äôt! ‚Äî then you will need to use an action to apply the event handler yourself.

Multiple event handlers
In Svelte 4, this is possible:


<button on:click={one} on:click={two}>...</button>
Duplicate attributes/properties on elements ‚Äî which now includes event handlers ‚Äî are not allowed. Instead, do this:


<button
	onclick={(e) => {
		one(e);
		two(e);
	}}
>
	...
</button>
When spreading props, local event handlers must go after the spread, or they risk being overwritten:


<button
	{...props}
	onclick={(e) => {
		doStuff(e);
		props.onclick?.(e);
	}}
>
	...
</button>
Snippets instead of slots
In Svelte 4, content can be passed to components using slots. Svelte 5 replaces them with snippets which are more powerful and flexible, and as such slots are deprecated in Svelte 5.

They continue to work, however, and you can mix and match snippets and slots in your components.

When using custom elements, you should still use <slot /> like before. In a future version, when Svelte removes its internal version of slots, it will leave those slots as-is, i.e. output a regular DOM tag instead of transforming it.

Default content
In Svelte 4, the easiest way to pass a piece of UI to the child was using a <slot />. In Svelte 5, this is done using the children prop instead, which is then shown with {@render children()}:


<script>
	let { children } = $props();
</script>

<slot />
{@render children?.()}
Multiple content placeholders
If you wanted multiple UI placeholders, you had to use named slots. In Svelte 5, use props instead, name them however you like and {@render ...} them:


<script>
	let { header, main, footer } = $props();
</script>

<header>
	<slot name="header" />
	{@render header()}
</header>

<main>
	<slot name="main" />
	{@render main()}
</main>

<footer>
	<slot name="header" />
	{@render footer()}
</footer>
Passing data back up
In Svelte 4, you would pass data to a <slot /> and then retrieve it with let: in the parent component. In Svelte 5, snippets take on that responsibility:

App

<script>
	import List from './List.svelte';
</script>

<List items={['one', 'two', 'three']} let:item>
	{#snippet item(text)}
		<span>{text}</span>
	{/snippet}
	<span slot="empty">No items yet</span>
	{#snippet empty()}
		<span>No items yet</span>
	{/snippet}
</List>
List

<script>
	let { items, item, empty } = $props();
</script>

{#if items.length}
	<ul>
		{#each items as entry}
			<li>
				<slot item={entry} />
				{@render item(entry)}
			</li>
		{/each}
	</ul>
{:else}
	<slot name="empty" />
	{@render empty?.()}
{/if}
Migration script
By now you should have a pretty good understanding of the before/after and how the old syntax relates to the new syntax. It probably also became clear that a lot of these migrations are rather technical and repetitive - something you don‚Äôt want to do by hand.

We thought the same, which is why we provide a migration script to do most of the migration automatically. You can upgrade your project by using npx sv migrate svelte-5. This will do the following things:

bump core dependencies in your package.json
migrate to runes (let -> $state etc)
migrate to event attributes for Dom elements (on:click -> onclick)
migrate slot creations to render tags (<slot /> -> {@render children()})
migrate slot usages to snippets (<div slot="x">...</div> -> {#snippet x()}<div>...</div>{/snippet})
migrate obvious component creations (new Component(...) -> mount(Component, ...))
You can also migrate a single component in VS Code through the Migrate Component to Svelte 5 Syntax command, or in our Playground through the Migrate button.

Not everything can be migrated automatically, and some migrations need manual cleanup afterwards. The following sections describe these in more detail.

run
You may see that the migration script converts some of your $: statements to a run function which is imported from svelte/legacy. This happens if the migration script couldn‚Äôt reliably migrate the statement to a $derived and concluded this is a side effect instead. In some cases this may be wrong and it‚Äôs best to change this to use a $derived instead. In other cases it may be right, but since $: statements also ran on the server but $effect does not, it isn‚Äôt safe to transform it as such. Instead, run is used as a stopgap solution. run mimics most of the characteristics of $:, in that it runs on the server once, and runs as $effect.pre on the client ($effect.pre runs before changes are applied to the DOM; most likely you want to use $effect instead).


<script>
	import { run } from 'svelte/legacy';
	run(() => {
	$effect(() => {
		// some side effect code
	})
</script>
Event modifiers
Event modifiers are not applicable to event attributes (e.g. you can‚Äôt do onclick|preventDefault={...}). Therefore, when migrating event directives to event attributes, we need a function-replacement for these modifiers. These are imported from svelte/legacy, and should be migrated away from in favor of e.g. just using event.preventDefault().


<script>
	import { preventDefault } from 'svelte/legacy';
</script>

<button
	onclick={preventDefault((event) => {
		event.preventDefault();
		// ...
	})}
>
	click me
</button>
Things that are not automigrated
The migration script does not convert createEventDispatcher. You need to adjust those parts manually. It doesn‚Äôt do it because it‚Äôs too risky because it could result in breakage for users of the component, which the migration script cannot find out.

The migration script does not convert beforeUpdate/afterUpdate. It doesn‚Äôt do it because it‚Äôs impossible to determine the actual intent of the code. As a rule of thumb you can often go with a combination of $effect.pre (runs at the same time as beforeUpdate did) and tick (imported from svelte, allows you to wait until changes are applied to the DOM and then do some work).

Components are no longer classes
In Svelte 3 and 4, components are classes. In Svelte 5 they are functions and should be instantiated differently. If you need to manually instantiate components, you should use mount or hydrate (imported from svelte) instead. If you see this error using SvelteKit, try updating to the latest version of SvelteKit first, which adds support for Svelte 5. If you‚Äôre using Svelte without SvelteKit, you‚Äôll likely have a main.js file (or similar) which you need to adjust:


import { mount } from 'svelte';
import App from './App.svelte'

const app = new App({ target: document.getElementById("app") });
const app = mount(App, { target: document.getElementById("app") });

export default app;
mount and hydrate have the exact same API. The difference is that hydrate will pick up the Svelte‚Äôs server-rendered HTML inside its target and hydrate it. Both return an object with the exports of the component and potentially property accessors (if compiled with accessors: true). They do not come with the $on, $set and $destroy methods you may know from the class component API. These are its replacements:

For $on, instead of listening to events, pass them via the events property on the options argument.


import { mount } from 'svelte';
import App from './App.svelte'

const app = new App({ target: document.getElementById("app") });
app.$on('event', callback);
const app = mount(App, { target: document.getElementById("app"), events: { event: callback } });
Note that using events is discouraged ‚Äî instead, use callbacks

For $set, use $state instead to create a reactive property object and manipulate it. If you‚Äôre doing this inside a .js or .ts file, adjust the ending to include .svelte, i.e. .svelte.js or .svelte.ts.


import { mount } from 'svelte';
import App from './App.svelte'

const app = new App({ target: document.getElementById("app"), props: { foo: 'bar' } });
app.$set({ foo: 'baz' });
const props = $state({ foo: 'bar' });
const app = mount(App, { target: document.getElementById("app"), props });
props.foo = 'baz';
For $destroy, use unmount instead.


import { mount, unmount } from 'svelte';
import App from './App.svelte'

const app = new App({ target: document.getElementById("app"), props: { foo: 'bar' } });
app.$destroy();
const app = mount(App, { target: document.getElementById("app") });
unmount(app);
As a stop-gap-solution, you can also use createClassComponent or asClassComponent (imported from svelte/legacy) instead to keep the same API known from Svelte 4 after instantiating.


import { createClassComponent } from 'svelte/legacy';
import App from './App.svelte'

const app = new App({ target: document.getElementById("app") });
const app = createClassComponent({ component: App, target: document.getElementById("app") });

export default app;
If this component is not under your control, you can use the compatibility.componentApi compiler option for auto-applied backwards compatibility, which means code using new Component(...) keeps working without adjustments (note that this adds a bit of overhead to each component). This will also add $set and $on methods for all component instances you get through bind:this.


/// svelte.config.js
export default {
	compilerOptions: {
		compatibility: {
			componentApi: 4
		}
	}
};
Note that mount and hydrate are not synchronous, so things like onMount won‚Äôt have been called by the time the function returns and the pending block of promises will not have been rendered yet (because #await waits a microtask to wait for a potentially immediately-resolved promise). If you need that guarantee, call flushSync (import from 'svelte') after calling mount/hydrate.

Server API changes
Similarly, components no longer have a render method when compiled for server side rendering. Instead, pass the function to render from svelte/server:


import { render } from 'svelte/server';
import App from './App.svelte';

const { html, head } = App.render({ props: { message: 'hello' }});
const { html, head } = render(App, { props: { message: 'hello' }});
In Svelte 4, rendering a component to a string also returned the CSS of all components. In Svelte 5, this is no longer the case by default because most of the time you‚Äôre using a tooling chain that takes care of it in other ways (like SvelteKit). If you need CSS to be returned from render, you can set the css compiler option to 'injected' and it will add <style> elements to the head.

Component typing changes
The change from classes towards functions is also reflected in the typings: SvelteComponent, the base class from Svelte 4, is deprecated in favour of the new Component type which defines the function shape of a Svelte component. To manually define a component shape in a d.ts file:


import type { Component } from 'svelte';
export declare const MyComponent: Component<{
	foo: string;
}>;
To declare that a component of a certain type is required:


<script lang="ts">
	import type { Component } from 'svelte';
	import {
		ComponentA,
		ComponentB
	} from 'component-library';

	let component: Component<{ foo: string }> = $state(
		Math.random() ? ComponentA : ComponentB
	);
</script>

<svelte:component this={component} foo="bar" />
The two utility types ComponentEvents and ComponentType are also deprecated. ComponentEvents is obsolete because events are defined as callback props now, and ComponentType is obsolete because the new Component type is the component type already (e.g. ComponentType<SvelteComponent<{ prop: string }>> == Component<{ prop: string }>).

bind:this changes
Because components are no longer classes, using bind:this no longer returns a class instance with $set, $on and $destroy methods on it. It only returns the instance exports (export function/const) and, if you‚Äôre using the accessors option, a getter/setter-pair for each property.

Whitespace handling changed
Previously, Svelte employed a very complicated algorithm to determine if whitespace should be kept or not. Svelte 5 simplifies this which makes it easier to reason about as a developer. The rules are:

Whitespace between nodes is collapsed to one whitespace
Whitespace at the start and end of a tag is removed completely
Certain exceptions apply such as keeping whitespace inside pre tags
As before, you can disable whitespace trimming by setting the preserveWhitespace option in your compiler settings or on a per-component basis in <svelte:options>.

Modern browser required
Svelte 5 requires a modern browser (in other words, not Internet Explorer) for various reasons:

it uses Proxies
elements with clientWidth / clientHeight/offsetWidth/offsetHeight bindings use a ResizeObserver rather than a convoluted <iframe> hack
<input type="range" bind:value={...} /> only uses an input event listener, rather than also listening for change events as a fallback
The legacy compiler option, which generated bulkier but IE-friendly code, no longer exists.

Changes to compiler options
The false / true (already deprecated previously) and the "none" values were removed as valid values from the css option
The legacy option was repurposed
The hydratable option has been removed. Svelte components are always hydratable now
The enableSourcemap option has been removed. Source maps are always generated now, tooling can choose to ignore it
The tag option was removed. Use <svelte:options customElement="tag-name" /> inside the component instead
The loopGuardTimeout, format, sveltePath, errorMode and varsReport options were removed
The children prop is reserved
Content inside component tags becomes a snippet prop called children. You cannot have a separate prop by that name.

Dot notation indicates a component
In Svelte 4, <foo.bar> would create an element with a tag name of "foo.bar". In Svelte 5, foo.bar is treated as a component instead. This is particularly useful inside each blocks:


{#each items as item}
	<item.component {...item.props} />
{/each}
Breaking changes in runes mode
Some breaking changes only apply once your component is in runes mode.

Bindings to component exports are not allowed
Exports from runes mode components cannot be bound to directly. For example, having export const foo = ... in component A and then doing <A bind:foo /> causes an error. Use bind:this instead ‚Äî <A bind:this={a} /> ‚Äî and access the export as a.foo. This change makes things easier to reason about, as it enforces a clear separation between props and exports.

Bindings need to be explicitly defined using $bindable()
In Svelte 4 syntax, every property (declared via export let) is bindable, meaning you can bind: to it. In runes mode, properties are not bindable by default: you need to denote bindable props with the $bindable rune.

If a bindable property has a default value (e.g. let { foo = $bindable('bar') } = $props();), you need to pass a non-undefined value to that property if you‚Äôre binding to it. This prevents ambiguous behavior ‚Äî the parent and child must have the same value ‚Äî and results in better performance (in Svelte 4, the default value was reflected back to the parent, resulting in wasteful additional render cycles).

accessors option is ignored
Setting the accessors option to true makes properties of a component directly accessible on the component instance. In runes mode, properties are never accessible on the component instance. You can use component exports instead if you need to expose them.

immutable option is ignored
Setting the immutable option has no effect in runes mode. This concept is replaced by how $state and its variations work.

Classes are no longer ‚Äúauto-reactive‚Äù
In Svelte 4, doing the following triggered reactivity:


<script>
	let foo = new Foo();
</script>

<button on:click={() => (foo.value = 1)}>{foo.value}</button
>
This is because the Svelte compiler treated the assignment to foo.value as an instruction to update anything that referenced foo. In Svelte 5, reactivity is determined at runtime rather than compile time, so you should define value as a reactive $state field on the Foo class. Wrapping new Foo() with $state(...) will have no effect ‚Äî only vanilla objects and arrays are made deeply reactive.

<svelte:component> is no longer necessary
In Svelte 4, components are static ‚Äî if you render <Thing>, and the value of Thing changes, nothing happens. To make it dynamic you must use <svelte:component>.

This is no longer true in Svelte 5:


<script>
	import A from './A.svelte';
	import B from './B.svelte';

	let Thing = $state();
</script>

<select bind:value={Thing}>
	<option value={A}>A</option>
	<option value={B}>B</option>
</select>

<!-- these are equivalent -->
<Thing />
<svelte:component this={Thing} />
Touch and wheel events are passive
When using onwheel, onmousewheel, ontouchstart and ontouchmove event attributes, the handlers are passive to align with browser defaults. This greatly improves responsiveness by allowing the browser to scroll the document immediately, rather than waiting to see if the event handler calls event.preventDefault().

In the very rare cases that you need to prevent these event defaults, you should use on instead (for example inside an action).

Attribute/prop syntax is stricter
In Svelte 4, complex attribute values needn‚Äôt be quoted:


<Component prop=this{is}valid />
This is a footgun. In runes mode, if you want to concatenate stuff you must wrap the value in quotes:


<Component prop="this{is}valid" />
Note that Svelte 5 will also warn if you have a single expression wrapped in quotes, like answer="{42}" ‚Äî in Svelte 6, that will cause the value to be converted to a string, rather than passed as a number.

HTML structure is stricter
In Svelte 4, you were allowed to write HTML code that would be repaired by the browser when server side rendering it. For example you could write this...


<table>
	<tr>
		<td>hi</td>
	</tr>
</table>
... and the browser would auto-insert a <tbody> element:


<table>
	<tbody>
		<tr>
			<td>hi</td>
		</tr>
	</tbody>
</table>
Svelte 5 is more strict about the HTML structure and will throw a compiler error in cases where the browser would repair the DOM.

Other breaking changes
Stricter @const assignment validation
Assignments to destructured parts of a @const declaration are no longer allowed. It was an oversight that this was ever allowed.

:is(...) and :where(...) are scoped
Previously, Svelte did not analyse selectors inside :is(...) and :where(...), effectively treating them as global. Svelte 5 analyses them in the context of the current component. As such, some selectors may now be treated as unused if they were relying on this treatment. To fix this, use :global(...) inside the :is(...)/:where(...) selectors.

When using Tailwind‚Äôs @apply directive, add a :global selector to preserve rules that use Tailwind-generated :is(...) selectors:


main :global {
	@apply bg-blue-100 dark:bg-blue-900;
}
CSS hash position no longer deterministic
Previously Svelte would always insert the CSS hash last. This is no longer guaranteed in Svelte 5. This is only breaking if you have very weird css selectors.

Scoped CSS uses :where(...)
To avoid issues caused by unpredictable specificity changes, scoped CSS selectors now use :where(.svelte-xyz123) selector modifiers alongside .svelte-xyz123 (where xyz123 is, as previously, a hash of the <style> contents). You can read more detail here.

In the event that you need to support ancient browsers that don‚Äôt implement :where, you can manually alter the emitted CSS, at the cost of unpredictable specificity changes:


css = css.replace(/:where\((.+?)\)/, '$1');

Error/warning codes have been renamed
Error and warning codes have been renamed. Previously they used dashes to separate the words, they now use underscores (e.g. foo-bar becomes foo_bar). Additionally, a handful of codes have been reworded slightly.

Reduced number of namespaces
The number of valid namespaces you can pass to the compiler option namespace has been reduced to html (the default), mathml and svg.

The foreign namespace was only useful for Svelte Native, which we‚Äôre planning to support differently in a 5.x minor.

beforeUpdate/afterUpdate changes
beforeUpdate no longer runs twice on initial render if it modifies a variable referenced in the template.

afterUpdate callbacks in a parent component will now run after afterUpdate callbacks in any child components.

Both functions are disallowed in runes mode ‚Äî use $effect.pre(...) and $effect(...) instead.

contenteditable behavior change
If you have a contenteditable node with a corresponding binding and a reactive value inside it (example: <div contenteditable=true bind:textContent>count is {count}</div>), then the value inside the contenteditable will not be updated by updates to count because the binding takes full control over the content immediately and it should only be updated through it.

oneventname attributes no longer accept string values
In Svelte 4, it was possible to specify event attributes on HTML elements as a string:


<button onclick="alert('hello')">...</button>
This is not recommended, and is no longer possible in Svelte 5, where properties like onclick replace on:click as the mechanism for adding event handlers.

null and undefined become the empty string
In Svelte 4, null and undefined were printed as the corresponding string. In 99 out of 100 cases you want this to become the empty string instead, which is also what most other frameworks out there do. Therefore, in Svelte 5, null and undefined become the empty string.

bind:files values can only be null, undefined or FileList
bind:files is now a two-way binding. As such, when setting a value, it needs to be either falsy (null or undefined) or of type FileList.

Bindings now react to form resets
Previously, bindings did not take into account reset event of forms, and therefore values could get out of sync with the DOM. Svelte 5 fixes this by placing a reset listener on the document and invoking bindings where necessary.

walk no longer exported
svelte/compiler reexported walk from estree-walker for convenience. This is no longer true in Svelte 5, import it directly from that package instead in case you need it.

Content inside svelte:options is forbidden
In Svelte 4 you could have content inside a <svelte:options /> tag. It was ignored, but you could write something in there. In Svelte 5, content inside that tag is a compiler error.

<slot> elements in declarative shadow roots are preserved
Svelte 4 replaced the <slot /> tag in all places with its own version of slots. Svelte 5 preserves them in the case they are a child of a <template shadowrootmode="..."> element.

<svelte:element> tag must be an expression
In Svelte 4, <svelte:element this="div"> is valid code. This makes little sense ‚Äî you should just do <div>. In the vanishingly rare case that you do need to use a literal value for some reason, you can do this:


<svelte:element this={"div"}>
Note that whereas Svelte 4 would treat <svelte:element this="input"> (for example) identically to <input> for the purposes of determining which bind: directives could be applied, Svelte 5 does not.

mount plays transitions by default
The mount function used to render a component tree plays transitions by default unless the intro option is set to false. This is different from legacy class components which, when manually instantiated, didn‚Äôt play transitions by default.

<img src={...}> and {@html ...} hydration mismatches are not repaired
In Svelte 4, if the value of a src attribute or {@html ...} tag differ between server and client (a.k.a. a hydration mismatch), the mismatch is repaired. This is very costly: setting a src attribute (even if it evaluates to the same thing) causes images and iframes to be reloaded, and reinserting a large blob of HTML is slow.

Since these mismatches are extremely rare, Svelte 5 assumes that the values are unchanged, but in development will warn you if they are not. To force an update you can do something like this:


<script>
	let { markup, src } = $props();

	if (typeof window !== 'undefined') {
		// stash the values...
		const initial = { markup, src };

		// unset them...
		markup = src = undefined;

		$effect(() => {
			// ...and reset after we've mounted
			markup = initial.markup;
			src = initial.src;
		});
	}
</script>

{@html markup}
<img {src} />
Hydration works differently
Svelte 5 makes use of comments during server side rendering which are used for more robust and efficient hydration on the client. As such, you shouldn‚Äôt remove comments from your HTML output if you intend to hydrate it, and if you manually authored HTML to be hydrated by a Svelte component, you need to adjust that HTML to include said comments at the correct positions.

onevent attributes are delegated
Event attributes replace event directives: Instead of on:click={handler} you write onclick={handler}. For backwards compatibility the on:event syntax is still supported and behaves the same as in Svelte 4. Some of the onevent attributes however are delegated, which means you need to take care to not stop event propagation on those manually, as they then might never reach the listener for this event type at the root.

--style-props uses a different element
Svelte 5 uses an extra <svelte-css-wrapper> element instead of a <div> to wrap the component when using CSS custom properties.

 Edit this page on GitHub

previous
next
Svelte 4 migration guide
Frequently asked questions
Cast runes, win prizes: SvelteHack 2024  
Svelte 5 migration guide ‚Ä¢ Docs ‚Ä¢ Svelte



Skip to main content
Introduction
Runes
Template syntax
Styling
Special elements
Runtime
Misc
Reference
Legacy APIs
SvelteMisc
TypeScript
On this page
TypeScript
<script lang=‚Äùts‚Äù>
Preprocessor setup
Typing $props
Generic $props
Typing wrapper components
Typing $state
The Component type
Enhancing built-in DOM types
You can use TypeScript within Svelte components. IDE extensions like the Svelte VS Code extension will help you catch errors right in your editor, and svelte-check does the same on the command line, which you can integrate into your CI.

<script lang="ts">
To use TypeScript inside your Svelte components, add lang="ts" to your script tags:


<script lang="ts">
	let name: string = 'world';

	function greet(name: string) {
		alert(`Hello, ${name}!`);
	}
</script>

<button onclick={(e: Event) => greet(e.target.innerText)}>
	{name as string}
</button>
Doing so allows you to use TypeScript‚Äôs type-only features. That is, all features that just disappear when transpiling to JavaScript, such as type annotations or interface declarations. Features that require the TypeScript compiler to output actual code are not supported. This includes:

using enums
using private, protected or public modifiers in constructor functions together with initializers
using features that are not yet part of the ECMAScript standard (i.e. not level 4 in the TC39 process) and therefore not implemented yet within Acorn, the parser we use for parsing JavaScript
If you want to use one of these features, you need to setup up a script preprocessor.

Preprocessor setup
To use non-type-only TypeScript features within Svelte components, you need to add a preprocessor that will turn TypeScript into JavaScript.

Using SvelteKit or Vite
The easiest way to get started is scaffolding a new SvelteKit project by typing npx sv create, following the prompts and choosing the TypeScript option.

svelte.config

import { vitePreprocess } from '@sveltejs/kit/vite';

const config = {
	preprocess: vitePreprocess()
};

export default config;
If you don‚Äôt need or want all the features SvelteKit has to offer, you can scaffold a Svelte-flavoured Vite project instead by typing npm create vite@latest and selecting the svelte-ts option.

svelte.config

import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

const config = {
	preprocess: vitePreprocess()
};

export default config;
In both cases, a svelte.config.js with vitePreprocess will be added. Vite/SvelteKit will read from this config file.

Other build tools
If you‚Äôre using tools like Rollup or Webpack instead, install their respective Svelte plugins. For Rollup that‚Äôs rollup-plugin-svelte and for Webpack that‚Äôs svelte-loader. For both, you need to install typescript and svelte-preprocess and add the preprocessor to the plugin config (see the respective READMEs for more info). If you‚Äôre starting a new project, you can also use the rollup or webpack template to scaffold the setup from a script.

If you‚Äôre starting a new project, we recommend using SvelteKit or Vite instead

Typing $props
Type $props just like a regular object with certain properties.


<script lang="ts">
	import type { Snippet } from 'svelte';

	interface Props {
		requiredProperty: number;
		optionalProperty?: boolean;
		snippetWithStringArgument: Snippet<[string]>;
		eventHandler: (arg: string) => void;
		[key: string]: unknown;
	}

	let {
		requiredProperty,
		optionalProperty,
		snippetWithStringArgument,
		eventHandler,
		...everythingElse
	}: Props = $props();
</script>

<button onclick={() => eventHandler('clicked button')}>
	{@render snippetWithStringArgument('hello')}
</button>
Generic $props
Components can declare a generic relationship between their properties. One example is a generic list component that receives a list of items and a callback property that receives an item from the list. To declare that the items property and the select callback operate on the same types, add the generics attribute to the script tag:


<script lang="ts" generics="Item extends { text: string }">
	interface Props {
		items: Item[];
		select(item: Item): void;
	}

	let { items, select }: Props = $props();
</script>

{#each items as item}
	<button onclick={() => select(item)}>
		{item.text}
	</button>
{/each}
The content of generics is what you would put between the <...> tags of a generic function. In other words, you can use multiple generics, extends and fallback types.

Typing wrapper components
In case you‚Äôre writing a component that wraps a native element, you may want to expose all the attributes of the underlying element to the user. In that case, use (or extend from) one of the interfaces provided by svelte/elements. Here‚Äôs an example for a Button component:


<script lang="ts">
	import type { HTMLButtonAttributes } from 'svelte/elements';

	let { children, ...rest }: HTMLButtonAttributes = $props();
</script>

<button {...rest}>
	{@render children()}
</button>
Not all elements have a dedicated type definition. For those without one, use SvelteHTMLElements:


<script lang="ts">
	import type { SvelteHTMLElements } from 'svelte/elements';

	let { children, ...rest }: SvelteHTMLElements['div'] = $props();
</script>

<div {...rest}>
	{@render children()}
</div>
Typing $state
You can type $state like any other variable.


let count: number = $state(0);
If you don‚Äôt give $state an initial value, part of its types will be undefined.


// Error: Type 'number | undefined' is not assignable to type 'number'
let count: number = $state();
If you know that the variable will be defined before you first use it, use an as casting. This is especially useful in the context of classes:


class Counter {
	count = $state() as number;
	constructor(initial: number) {
		this.count = initial;
	}
}
The Component type
Svelte components are of type Component. You can use it and its related types to express a variety of constraints.

Using it together with dynamic components to restrict what kinds of component can be passed to it:


<script lang="ts">
	import type { Component } from 'svelte';

	interface Props {
		// only components that have at most the "prop"
		// property required can be passed
		DynamicComponent: Component<{ prop: string }>;
	}

	let { DynamicComponent }: Props = $props();
</script>

<DynamicComponent prop="foo" />
In Svelte 4, components were of type SvelteComponent

To extract the properties from a component, use ComponentProps.


import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps<TComponent extends Component<any>>(
	component: TComponent,
	props: ComponentProps<TComponent>
) {}

// Errors if the second argument is not the correct props expected
// by the component in the first argument.
withProps(MyComponent, { foo: 'bar' });
To declare that a variable expects the constructor or instance type of a component:


<script lang="ts">
	import MyComponent from './MyComponent.svelte';

	let componentConstructor: typeof MyComponent = MyComponent;
	let componentInstance: MyComponent;
</script>

<MyComponent bind:this={componentInstance} />
Enhancing built-in DOM types
Svelte provides a best effort of all the HTML DOM types that exist. Sometimes you may want to use experimental attributes or custom events coming from an action. In these cases, TypeScript will throw a type error, saying that it does not know these types. If it‚Äôs a non-experimental standard attribute/event, this may very well be a missing typing from our HTML typings. In that case, you are welcome to open an issue and/or a PR fixing it.

In case this is a custom or experimental attribute/event, you can enhance the typings like this:

additional-svelte-typings.d

declare namespace svelteHTML {
	// enhance elements
	interface IntrinsicElements {
		'my-custom-element': { someattribute: string; 'on:event': (e: CustomEvent<any>) => void };
	}
	// enhance attributes
	interface HTMLAttributes<T> {
		// If you want to use the beforeinstallprompt event
		onbeforeinstallprompt?: (event: any) => any;
		// If you want to use myCustomAttribute={..} (note: all lowercase)
		mycustomattribute?: any; // You can replace any with something more specific if you like
	}
}
Then make sure that d.ts file is referenced in your tsconfig.json. If it reads something like "include": ["src/**/*"] and your d.ts file is inside src, it should work. You may need to reload for the changes to take effect.

You can also declare the typings by augmenting the svelte/elements module like this:

additional-svelte-typings.d

import { HTMLButtonAttributes } from 'svelte/elements';

declare module 'svelte/elements' {
	export interface SvelteHTMLElements {
		'custom-button': HTMLButtonAttributes;
	}

	// allows for more granular control over what element to add the typings to
	export interface HTMLButtonAttributes {
		veryexperimentalattribute?: string;
	}
}

export {}; // ensure this is not an ambient module, else types will be overridden instead of augmented
 Edit this page on GitHub

previous
next
Testing
Custom elements
Cast runes, win prizes: SvelteHack 2024  
